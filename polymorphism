(* # Polymorphism is defined as  one object can behave in  multiple forms
#implementing polymorphism in 4 ways 
#1.Duck typing 2.Operator overloading 3.Method overloading 4.Method overriding *)
(*Duck typing in python:
-->>In standard languages like c,c++or java we wanrt to define type of an object
-->> But in python it's different ,there is no need of declaring a type
--->> so,we don't check the type of an object,we only care about that particular object have required method /behaviour
*)
Ex:
class Duck:
    def quack(self):
       print("quack quack")
class dog:
    def quack(self):
      print("I can bark but trying to quack... Woof-Quack!quack")
def make_it_quack(thing):
    thing.quack()
duck=duck()
duck.quack()
dog=dog()
dog.quack()
operator ovverloading :Operator overloading is  a process of giving a special meaning to operator when they are used with user defined classes or objects 
Ex:

class student:
  def __init__(self,m1,m2):
    self.m1=m1
    self.m2=m2
  def __add__(self,other):
    m1=self.m1 + other.m1
    m2=self.m2 + other.m2
    s3=student(m1,m2)
    return s3
  def __mul__(self,other):
    m1=self.m1*other.m1
    m2=self.m2*other.m2
    
  def __gt__(self,other):
    r1=self.m1+self.m2
    r2=other.m1+other.m2
    if r1>r2:
      return True
    else:
      return False
s1=student(50,20)
s2=student(50,20)
s3=s1+s2
if s1>s2:
  print("s1 wins")
else:
  print("s2 wins")


3) Method overloading :  In python true method overloading doesnot support.But we call a same method by entering  different parameters.
ex:
class a:
  def __init__ (self,a=0,b=0):
    self.a=a
    self.b=b
  def add(self,a=None,b=None):
    if a!=None and b!=None:
      return a+b
    elif a!=None:
      return a+self.b
    else:
      return self.a+self.b
a1=a()
print(a1.add(10))
print(a1.add(20,30))
print(a1.add())



